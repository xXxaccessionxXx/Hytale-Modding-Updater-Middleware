package com.hytale.updater.mapper;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;

/**
 * Modular mapping class that securely transforms a generic, untyped source
 * payload
 * (like a parsed JSON object represented as a Map) into a strictly typed target
 * model.
 *
 * Designed to be highly decoupled. New data sources only require a new
 * Configuration Map
 * (MappingContext) without altering the engine logic.
 *
 * @param <T> The target strongly-typed model.
 */
public class DataMapper<T> {

    private final Function<Map<String, Object>, T> targetFactory;
    private final Map<String, FieldRule<T, ?>> rules = new HashMap<>();

    /**
     * @param targetFactory A function that instantiates the target type T.
     */
    public DataMapper(Function<Map<String, Object>, T> targetFactory) {
        this.targetFactory = targetFactory;
    }

    /**
     * Registers a mapping rule for a specific field in the source payload.
     *
     * @param sourceKey    The untyped source data key (e.g., "old_id").
     * @param expectedType The expected class type in the untyped payload, for
     *                     safety checking.
     * @param isRequired   Whether this field must be present to successfully map.
     * @param setter       A function detailing how to apply the mapped value to the
     *                     target object.
     * @return The current mapper instance for method chaining.
     */
    public <V> DataMapper<T> withRule(String sourceKey, Class<V> expectedType, boolean isRequired,
            FieldSetter<T, V> setter) {
        rules.put(sourceKey, new FieldRule<>(expectedType, isRequired, setter));
        return this;
    }

    /**
     * Transforms the untyped map payload into the strictly typed Target Schema.
     *
     * @param untypedSource Data payload, commonly Maps recursively generated by
     *                      JSON parsers.
     * @return An Optional containing the populated target object, or empty if
     *         validation failed.
     */
    public Optional<T> map(Map<String, Object> untypedSource) {
        if (untypedSource == null)
            return Optional.empty();

        try {
            // Instantiate target schema
            T targetInstance = targetFactory.apply(untypedSource);

            for (Map.Entry<String, FieldRule<T, ?>> entry : rules.entrySet()) {
                String key = entry.getKey();
                FieldRule<T, ?> rule = entry.getValue();

                if (!untypedSource.containsKey(key)) {
                    if (rule.isRequired) {
                        throw new MappingException("Required field missing in payload: " + key);
                    }
                    continue; // Skip optional missing fields
                }

                Object rawValue = untypedSource.get(key);

                // Handle null values inside the payload safely
                if (rawValue == null) {
                    if (rule.isRequired) {
                        throw new MappingException("Required field '" + key + "' was null.");
                    }
                    continue; // Optional field is explicitly null, skip mapping
                }

                // Type verification
                if (!rule.expectedType.isInstance(rawValue)) {
                    throw new MappingException("Type mismatch for '" + key +
                            "'. Expected " + rule.expectedType.getSimpleName() +
                            ", got " + rawValue.getClass().getSimpleName());
                }

                // Apply mapped value safely
                @SuppressWarnings("unchecked")
                FieldSetter<T, Object> setter = (FieldSetter<T, Object>) rule.setter;
                setter.apply(targetInstance, rawValue);
            }

            return Optional.of(targetInstance);

        } catch (MappingException e) {
            System.err.println("Mapping Validation Error: " + e.getMessage());
            return Optional.empty();
        } catch (Exception e) {
            System.err.println("Unexpected Critical Mapping Error: " + e.getMessage());
            return Optional.empty();
        }
    }

    // --- Configuration Classes ---

    private static class FieldRule<T, V> {
        final Class<V> expectedType;
        final boolean isRequired;
        final FieldSetter<T, V> setter;

        FieldRule(Class<V> expectedType, boolean isRequired, FieldSetter<T, V> setter) {
            this.expectedType = expectedType;
            this.isRequired = isRequired;
            this.setter = setter;
        }
    }

    @FunctionalInterface
    public interface FieldSetter<Target, Value> {
        void apply(Target target, Value value);
    }

    public static class MappingException extends RuntimeException {
        public MappingException(String message) {
            super(message);
        }
    }
}
